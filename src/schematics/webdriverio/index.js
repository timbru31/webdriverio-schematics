"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webdriverioSchematics = void 0;
const fs = require("fs");
const path = require("path");
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const operators_1 = require("rxjs/operators");
const rxjs_1 = require("rxjs");
const config_1 = require("@wdio/cli/build/commands/config");
const constants_1 = require("./constants");
const types_1 = require("./types");
const utils_1 = require("./utils");
// You don't have to export the function as default. You can also have more than one rule factory
// per file.
function webdriverioSchematics(_options) {
    return (tree, _context) => {
        _options = Object.assign(Object.assign({}, _options), { __version__: utils_1.getAngularVersion(tree) });
        return schematics_1.chain([
            updateDependencies(_options),
            _options.removeProtractor ? removeFiles() : schematics_1.noop(),
            runWizard(_options),
            !_options.noBuilder ? modifyAngularJson(_options) : schematics_1.noop(),
        ])(tree, _context);
    };
}
exports.webdriverioSchematics = webdriverioSchematics;
function updateDependencies(options) {
    let removeDependencies;
    return (tree, context) => {
        context.logger.debug('Updating dependencies...');
        context.addTask(new tasks_1.NodePackageInstallTask());
        if (options.removeProtractor) {
            removeDependencies = rxjs_1.of('protractor').pipe(operators_1.map((packageName) => {
                context.logger.debug(`Removing ${packageName} dependency`);
                utils_1.removePackageJsonDependency(tree, {
                    type: types_1.NodeDependencyType.Dev,
                    name: packageName,
                });
                return tree;
            }));
        }
        const addDependencies = rxjs_1.of('@wdio/cli').pipe(operators_1.concatMap((packageName) => utils_1.getLatestNodeVersion(packageName)), operators_1.map((packageFromRegistry) => {
            const { name, version } = packageFromRegistry;
            context.logger.debug(`Adding ${name}:${version} to ${types_1.NodeDependencyType.Dev}`);
            utils_1.addPackageJsonDependency(tree, {
                type: types_1.NodeDependencyType.Dev,
                name,
                version,
            });
            return tree;
        }));
        if (options.removeProtractor) {
            return rxjs_1.concat(removeDependencies, addDependencies);
        }
        return rxjs_1.concat(addDependencies);
    };
}
function removeFiles() {
    return (tree, context) => {
        if (!tree.exists('./angular.json')) {
            return tree;
        }
        const angularJsonValue = utils_1.getAngularJsonValue(tree);
        const { projects } = angularJsonValue;
        // clean up projects generated by cli with versions <= 7
        Object.keys(projects)
            .filter((name) => name.endsWith('-e2e'))
            .forEach((projectName) => {
            const projectRoot = projects[projectName].root;
            utils_1.deleteDirectory(tree, projectRoot);
            context.logger.debug(`Removing ${projectName} from angular.json projects`);
            delete angularJsonValue.projects[projectName];
        });
        // clean up projects generated by cli with versions > 7
        Object.keys(projects)
            .filter((name) => !name.endsWith('-e2e'))
            .forEach((projectName) => {
            const projectRoot = projects[projectName].root;
            utils_1.deleteDirectory(tree, `${projectRoot}/e2e`);
        });
        return tree.overwrite('./angular.json', JSON.stringify(angularJsonValue, null, 2));
    };
}
function runWizard(_options) {
    return (tree, context) => (rxjs_1.concat(config_1.handler(_options)).pipe(operators_1.map(({ installedPackages }) => installedPackages), operators_1.concatMap((packageNames) => (Promise.all(packageNames.map((packageName) => utils_1.getLatestNodeVersion(packageName))))), operators_1.map(updateFiles(tree, context))));
}
function updateFiles(tree, context) {
    return (packagesFromRegistry) => {
        for (let packageFromRegistry of packagesFromRegistry) {
            const { name, version } = packageFromRegistry;
            context.logger.debug(`Adding ${name}:${version} to ${types_1.NodeDependencyType.Dev}`);
            utils_1.addPackageJsonDependency(tree, {
                type: types_1.NodeDependencyType.Dev,
                name,
                version,
            });
        }
        constants_1.TS_CONFIG.compilerOptions.types.push(...packagesFromRegistry
            .map((pkg) => pkg.name)
            .filter((pkg) => pkg.startsWith('@wdio')));
        fs.writeFileSync(path.join(process.cwd(), 'test', 'tsconfig.e2e.json'), JSON.stringify(constants_1.TS_CONFIG, null, 4));
        const wdioConfigPath = path.join(process.cwd(), 'wdio.conf.js');
        const wdioConfig = fs.readFileSync(wdioConfigPath).toString();
        fs.writeFileSync(wdioConfigPath, (wdioConfig.slice(0, -4) + '\n' +
            '    autoCompileOpts: {\n' +
            '        tsNodeOpts: {\n' +
            '            transpileOnly: true,\n' +
            '            project: __dirname + \'/test/tsconfig.e2e.json\'\n' +
            '        }\n' +
            '    }\n' +
            '}\n'));
        return tree;
    };
}
function modifyAngularJson(options) {
    return (tree, context) => {
        if (!tree.exists('./angular.json')) {
            throw new schematics_1.SchematicsException('angular.json not found');
        }
        const angularJsonVal = utils_1.getAngularJsonValue(tree);
        const { projects } = angularJsonVal;
        if (!projects) {
            throw new schematics_1.SchematicsException('projects in angular.json is not defined');
        }
        Object.keys(projects).forEach((project) => {
            const wdioConf = {
                builder: '@wdio/schematics:wdio',
                options: {
                    devServerTarget: `${project}:serve`,
                },
                configurations: {
                    production: {
                        devServerTarget: `${project}:serve:production`,
                    }
                }
            };
            const configFile = !!projects[project].root
                ? `${projects[project].root}/wdio.conf.js`
                : null;
            if (configFile) {
                Object.assign(wdioConf.options, { configFile });
            }
            if (options.removeProtractor) {
                context.logger.debug(`Replacing e2e command with wdio-run in angular.json`);
                utils_1.removeE2ELinting(tree, angularJsonVal, project);
            }
            context.logger.debug(`Adding webdriverio/tsconfig.json to angular.json-tslint config`);
            utils_1.addWDIOTsConfig(tree, angularJsonVal, project);
            context.logger.debug(`Adding wdio-run command in angular.json`);
            const projectArchitectJson = angularJsonVal['projects'][project]['architect'];
            projectArchitectJson['wdio-run'] = wdioConf;
            if (options.removeProtractor) {
                projectArchitectJson['e2e'] = wdioConf;
            }
            return tree.overwrite('./angular.json', JSON.stringify(angularJsonVal, null, 2));
        });
        return tree;
    };
}
//# sourceMappingURL=index.js.map